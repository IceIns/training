<center><h1>Educational Codeforces Round</h1></center>

## edu 169

### A.

题意简化：

给定数轴上 $n$ 个点，判断是否存在一个点满足离每个点最近的点都是这个点，且这个点不与 $n$ 个点重合。

解法：

容易发现，一个点只有在两个点之间时才能同时是离两个点最近的点。

所以 $n>2$ 时显然无解，反之需要两点之间有空才能有解，也就是 $b-a>1$。

### B.

题意简化：

Alice 可能在 $[l,r]$，Bob 可能在 $[L,R]$，求最少需要覆盖多少点使得所有情况下 Alice 和 Bob 之间都有点。

解法：

注意到：$r<L$ 获 $R<l$ 时只要覆盖 $r$ 或 $R$ 即可。

反之，需要覆盖 $[l,r]$ 和 $[L,R]$ 的所有交集。容易证明，若没有完全覆盖交集，Alice 和 Bob 均落在交集上即可。

### C.

题意简化：

给定 $n$ 个数，Alice 和 Bob 轮流取数，设 $A$ 为 Alice 取数之和，$B$ 为 Bob 取数之和，Alice 期望最大化 $A-B$，Bob 期望最小化 $A-B$。Bob 可以选择若干数增加总量不超过 $k$，求 $A-B$。

解法：

容易贪心，若不考虑增量，Alice 和 Bob 一定是轮流取当前最大值。

所以 Bob 要最小化 $A-B$ 就要尽可能最大化 $B$，所以在 Bob 取的数上增加到不改变元素之间大小关系的上限即可。

### D.

题意简化：

$n$ 个位置，每个位置两种颜色，总共四种颜色，若两个位置有共同颜色，则可以传送。$q$ 次询问从 $x$ 到 $y$ 的最少传送距离之和。

解法一：

直接在颜色之间建分层图，跑四次最短路即可。

解法二：

贪心地，$x,y$ 的最短距离即为 $|x-y|$。

分讨：

- $x,y$ 有公共颜色，答案即为 $|x-y|$
- $x,y$ 没有公共颜色，则 $x,y$ 包含了所有颜色。在 $x,y$ 之间若没有各包含 $x,y$ 颜色的位置，则 $x,y$ 向两侧找到最近的颜色集合不和 $x,y$ 相同的位置作为中转即可。

### E.

题意简化：

给定 $n$ 堆石子，Alice 和 Bob 轮流操作，每次可以选择一堆石子取出和石子总数互质数量的石子。求谁胜。

解法：

nim 游戏加 sg 函数打表。

nim 游戏先手必胜的条件是 $\oplus_{i=1}^nsg(a_i)\ne 0$。

对于一堆石子 $sg(x)=\text{mex}\{sg(x-y),\gcd(x,y)=1\}$，暴力打出 $sg(x)$ 的表，观察可得：

- $sg(1)=1$。
- 若 $x$ 是偶数，$sg(x)=0$。
- 若 $x$ 是质数，$sg(x)=x$ 是第几个质数。
- 若 $x$ 是合数，$sg(x)=sg(p)$，其中 $p$ 是其最小的质数，也就是其最小的质数是第几个质数。

因为 $x\le 10^7$，所以需要使用线性筛处理 $sg(x)$。

### F.

题意简化：

定义一个序列的权值是使用下述两种操作使得序列成为回文序列的最小操作次数：

- 选择两个相邻的元素，$b_i,b_{i+1}$ 合并成 $b_i+b_{i+1}$
- 选择任一 $b_i>1$，替换成 $x,b_i-x,0<x<b_i$

给定一个序列，求其所有连续子序列权值和。

解法：

合并和分裂两种操作不容易考虑，容易发现，分裂操作始终能等价为次数不更多的合并操作。

若通过分裂使 $x,b_i-x$ 对应 $b_j,b_{j+1}$，和将 $b_j,b_{j+1}$ 合并成 $b_j+b_{j+1}$ 以对应 $b_i$ 是等价的。

所以事实上可以只考虑合并操作。

此时，问题是容易的，对于一个确定的序列，要通过合并形成回文，那一定是前缀等于后缀，贪心地，每次取最短的合法前缀后缀即可。

暴力取是 $O(n^3)$ 的。

考虑每一个区间的贡献，一个区间 $[l,r]$ 有 $1$ 贡献当且仅当 $\sum\limits_{i=l}^ra_i=\sum\limits_{j=L}^R a_i,L>r$。

而这个问题直接做也是二维偏序的，虽然可做，但是相对复杂。

一个简单的做法是，因为 $[l,r]$ 和 $[L,R]$ 互相有贡献，总共 $2$ 的贡献，若考虑相交，即 $[l,L-1]$ 和 $[r+1,R]$ 等价于 $[l,r]$ 和 $[L,R]$，而此时只需要把贡献算在 $[l,L-1]$ 上即可，也就是只需要满足 $R>r$，此时是一个一维偏序。从后向前枚举，用一个 `map` 存储后缀和即可。

时间复杂度：$O(n^2\log n)$。

### G.

科技题。

ddp。



## edu 168

### A.

题意简化：

给定一个字符串，定义 $f(s)=\sum\limits_{i=1}^{|s|}[s_i=s_{i-1}]+2\times[s_i\ne s_{i-1}]$，求给 $s$ 插入一个字符后能达到的最大 $f(s)$。

解法：

贪心地，插入两个相同字符之间一定最优。若不存在g两个连续相同字符，末尾插入任一不同字符即可。

### B.

题意简化：

给定一个 $2\times n$ 的 01 矩阵，两个相邻的格子视作连通，初始只有一个 $0$ 的连通块，求使一个格子从 0 到 1 后连通块数量为 $3$ 的方案数。

解法一：

注意到，需要增加两个连通块，那么这一个格子的另一行上相邻的格子一定是 $1$。

特判一种情况，某一侧全是 $1$，此时不会增加两个。

解法二：

无脑 LCT。

### C.

题意简化：

给定一个残缺的括号序列，要求补成合法括号序列匹配后，所有匹配的括号对的距离之和最小。

解法：

贪心地，`)` 能匹配就匹配，不能匹配就放 `(`。

### D.

题意简化：

给定一棵有根树，每次可以选择一个子树，将其根节点权值加 $1$，其余点权值减 $1$，要求过程中所有权值非负，求根节点权值最大能是多少。

解法一：

对于根节点，其结果是所有子树中，最小值的最大值。

对于根节点的子树，要把整棵子树的最小值最大化。

最小值最大容易想到二分。

- $a_x\ge mid$，递归计算 $(y,mid)$
- $a_x<mid$，递归计算 $(y,mid+(mid-a_x))$

其中 $y$ 是 $x$ 子节点。

注意一个地方：不断累计的 $mid+(mid-a_x)$，可能会超过 `long long` 范围，容易构造 $a_x=1,mid=10^9$，时，最大值会达到约 $10^9\times 2^{n}$。

容易发现这种情况下一定是无解的，所以当 $mid+(mid-a_x)$ 超过一定上限后，返回无解即可。

时间复杂度：$O(n\log n)$。

### E.

题意简化：

给定一个序列，$t$ 初值 $0$，从 $a_1$ 到 $a_n$ 每经过 $k$ 个 $>t$ 的数，$t$ 加 $1$，$q$ 次询问，若 $k=x$，则经过 $a_y$ 时，$t$ 和 $a_y$ 的大小关系。

解法一：

在线不好做，考虑离线。

容易发现，等级最多提升 $\frac{n}{k}$ 次。

- 对于 $\frac{n}{k}>B,k<\frac{n}{B}$，暴力遍历，时间复杂度：$O(\frac{n^2}{B})$。
- 对于 $\frac{n}{k}\le B$，每次要求右侧最近的区间内 $>t$ 的数不少于 $k$ 的位置，容易使用二分前缀和实现，时间复杂度：$O((n-\frac{n}{B})B\log n)$。

实测 $B$ 取 $3000$ 可以通过。

空间复杂度：$O(\frac{n^2}{B})$，$k<\frac{n}{B}$ 的答案需要使用 `bitset` 存储。

解法二：

总共升级的次数是 $\frac{n}{1}+\frac{n}{2}+...+\frac{n}{n}=O(n\ln n)$。

若能快速维护每一次升级的区间，即可解决问题。

每一次升级的问题为求右侧最近的区间内 $>t$ 的数不少于 $k$ 的位置。

若维护出所有 $>t$ 的下标，最近的位置，容易通过线段树二分得到。

所以使用一棵版本号对应值域，值域对应序列下标的主席树，一次升级即为在 $[t,2\times 10^5]$ 版本的主席树上维护 $[l,n]$ 之间最近的区间和 $\ge k$ 的位置，区间而非全局的主席树上二分不容易做，但是注意到这里序列上都是正值，所以可以将 $k$ 加上 $[1,l-1]$ 的和，等价于维护 $[1,n]$ 中 $\ge k+\sum [1,l-1]$ 的最近位置，套用主席树上二分即可。

$[1,l-1]$ 的和在主席树上区间询问即可得到。

时间复杂度：$O(n\ln n\log n)$。

解法三：

注意到，对于每一个数，满足，经过它时，$t>a_i$ 的 $k$ 是单调的。当 $k\ge k'$ 时都是满足的。

所以对于每一个 $a_i$ 可以尝试二分求解 $k'$，判断 $k'$ 是否合法时，在于判断 $[1,i]$ 中是否至少经过了 $k'\times a_i$ 个 $t>a_i$ 的数。

而如果是从前处理到后，那么 $a_1,...,a_{i-1}$ 所对应的 $k_j'$ 是已求解的，只要求有多少满足 $k'_i\ge k'_j$ 的即可。

容易使用树状数组维护。

时间复杂度：$O(n\log^2n)$。

同时，容易发现上述问题即为在树状数组上找到最小的满足前缀和不小于 $k'_i\times a_i$ 的位置，使用树状数组上倍增即可优化至 $O(n\log n)$。



### F.

## edu 167

### A.

题意简化：

解法：

## edu 166

## edu 165

## edu 164

## edu 163

## edu 162

## edu 161

## edu 160 